#! /usr/bin/perl 

### Manjusha Pande, mpande@umich.edu, 12/05/13
### This script takes the read length disribution per fastq.gz file generated by CalculateReadLength.pl, calulates per sample mean and standard deviation of read length, 
### and complies that for all samples into a file 
### Usage: $ perl /ccmb/BioinfCore/Projects/Manjusha/RNA-seq_pipeline/RSQ_scripts/GetReadLength.pl <inDir> <outDir> 
### Example: perl /ccmb/BioinfCore/Projects/Manjusha/RNA-seq_pipeline/RSQ_scripts/GetReadLength.pl /ccmb/home/mpande/RNA-seq_pipeline/PE_inner_dist_tophat_test/reads/readCountLength /ccmb/home/mpande/RNA-seq_pipeline/PE_inner_dist_tophat_test/runInfo
### Example: /ccmb/BioinfCore/Projects/Manjusha/RNA-seq_pipeline/RSQ_scripts/GetReadLength.pl /ccmb/BioinfCore/Projects/Hu_826_pathu_mceachin_mpande_RS2/reads/readCountLength /ccmb/BioinfCore/Projects/Hu_826_pathu_mceachin_mpande_RS2/runInfo
#########################################################################################################################
use strict;
use warnings;
use Data::Dumper;
#use Number::Format;

my $inDir = $ARGV[0];
my $outDir = $ARGV[1];
my $pe = 0;
unless (-e $outDir || mkdir ($outDir, 0775)) {
	die "Unable to create $outDir \n";
};
my @inFiles = glob("$inDir/Sample_*_readCountandLength.txt");
my %readCounts = ();

foreach my $f (@inFiles) {
	my @tmp = split (/\//, $f);
	my $sample = $tmp[$#tmp];
	$sample =~ s/_R\d+_readCountandLength.txt//;
	open (RCL, "<$f") || die "Cannot open $f $!\n";
	while (<RCL>) {
		chomp $_;
		push (@{$readCounts{$sample}}, $_);
	}
}
#print Dumper %readCounts;
#print Dumper keys(%readCounts);

#=pod
my %sample_pairs = ();
for my $k (keys %readCounts) {
	my $sample_name = $k;
	$sample_name =~ s/_R.*//;
	if ($k =~ /R1/) {
		@{$sample_pairs{$sample_name}}[0] = $k;
	} elsif ($k =~ /R2/) {
		@{$sample_pairs{$sample_name}}[1] = $k;
		$pe = 1;
	}		
}
print "\n";
#print Dumper %sample_pairs;
open (OUTFILE, ">${outDir}/readCountandLength.txt") || die "Cannot open ${outDir}/readCountandLength.txt for writing\n";
if ($pe) {
	print OUTFILE "#Sample\tRead Count\tMean Read Length R1\tSD Read Length R1\tMean Read Length R2\tSD Read Length R2\n";
} else { print OUTFILE "#Sample\tRead Count\tMean Read Length\tSD Read Length\n";
}
my @samples = sort (keys %sample_pairs);
for my $k (@samples) {	
	print OUTFILE "$k\t";
	my @readLengths1 = @{$readCounts{@{$sample_pairs{$k}}[0]}};
	#print "@readLengths1[0..$#readLengths1]\n";
	my $sum1 = 0;
	my $readCount1 = 0;
	my $sumSqrd1 = 0;
	foreach my $r1 (@readLengths1) {
		my @r1 = $r1 =~ m/(\d+)/g;
		$sum1 = $sum1 + ($r1[0] * $r1[1]);
		$readCount1 = $readCount1 + $r1[0];	
	}
	my $mean_readLength1 = $sum1 / $readCount1;
	foreach my $r1 (@readLengths1) {
		my @r1 = $r1 =~ m/(\d+)/g;
		$sumSqrd1 = $sumSqrd1 + ($r1[0] * ($r1[1] - $mean_readLength1) * ($r1[1] - $mean_readLength1));
	}

	#### Calculating SD = sqrt ((X - Xmean)^2 / N-1)
	my $sd_readLength1 = sqrt ($sumSqrd1 / ($readCount1 - 1));
	$mean_readLength1 = sprintf ("%.2f", $mean_readLength1);
	$sd_readLength1 = sprintf ("%.2f", $sd_readLength1);
	#my $num = new Number::Format;
	#$formatted_rc = $num->format_number($readCount1); ## insert , between groups of 3 digits
	print OUTFILE "$readCount1\t$mean_readLength1\t$sd_readLength1";
	if (defined (@{$sample_pairs{$k}}[1])) {
		my @readLengths2 = @{$readCounts{@{$sample_pairs{$k}}[1]}};
		#print "@readLengths2[0..$#readLengths2]\n";
		my $sum2 = 0;
		my $readCount2 = 0;
		my $sumSqrd2 = 0;
		foreach my $r2 (@readLengths2) {
			my @r2 = $r2 =~ m/(\d+)/g;
			$sum2 = $sum2 + ($r2[0] * $r2[1]);
			$readCount2 = $readCount2 + $r2[0];
		}
		my $mean_readLength2 = $sum2 / $readCount2;
		foreach my $r2 (@readLengths2) {
		my @r2 = $r2 =~ m/(\d+)/g;
		$sumSqrd2 = $sumSqrd2 + ($r2[0] * ($r2[1] - $mean_readLength2) * ($r2[1] - $mean_readLength2));
	}
		my $sd_readLength2 = sqrt ($sumSqrd2 / ($readCount2 - 1));
		$mean_readLength2 = sprintf ("%.2f", $mean_readLength2);
		$sd_readLength2 = sprintf ("%.2f", $sd_readLength2);
		print OUTFILE "\t$mean_readLength2\t$sd_readLength2";		
	}
	print OUTFILE "\n";
}
close OUTFILE;
#=cut
