#!/bin/bash
# Launches snakemake

export WATERMELON_VERSION=0.2.4.x

export SCRIPT_NAME=`basename $0 .sh`
export WATERMELON_ROOT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )"/.. && pwd )"
export RUN_TIME=`date +"%Y%m%d_%H%M%S"`
export LOG_DIR=logs/${RUN_TIME}
export LOG_FILE=${LOG_DIR}/${SCRIPT_NAME}.log
export SNAKEFILE=${WATERMELON_ROOT_DIR}/rnaseq.snakefile
export WATERMELON_SCRIPTS_DIR=${WATERMELON_ROOT_DIR}/scripts

export CONFIG_FILE='config.yaml'
export CORES=40
export DRYRUN=""
export DAG=""
export PASS_THROUGH_ARGS=()
export MAIL_FROM='bfx-rnaseq-pipeline@umich.edu'
export MAIL_CC="${MAIL_FROM}"
export MAIL_TO="${USER}@umich.edu"
export SKIP_CONFIG_VALIDATION=""

SNAKEMAKE_VERSION=$(snakemake --version 2>/dev/null)
if ! [[ $SNAKEMAKE_VERSION ]]; then
  echo "ERROR: snakemake not found; is the python3 module loaded correctly? (contact bfxcore support for assistance)"
  exit 1
fi

set -e #script will fail on any error
set -u #script will fail on any undefined bash variable

function show_usage {
cat <<USAGE_HERE
Usage: ${SCRIPT_NAME} [options] -c {config_file}
Example: ${SCRIPT_NAME} -c ~/my_config.yaml

Executes the RNA-seq workflow by wrapping the snakemake call, specifically setting common,
useful defaults and passing through any unrecognized command line options through to
snakemake. Captures all outputs in a log and times overall execution.

Also see the companion executable watermelon-init which creates a watermelon config
file based on specified sequence dirs.
See "watermelon-init --help" for more info.

Options:
    -c, --configfile : [config.yaml] snakemake config file
    --cores [N]      : =40, use at most N cores in parallel
    --dag            : create DAG files (in working dir) to visualize execution plan
    -n, --dryrun     : show plan without executing anything
    --help           : shows this message

v${WATERMELON_VERSION}
USAGE_HERE
}

function set_expanded_options {
    EXPANDED_OPTIONS=()
    for arg in "$@"; do
        if [[ "$arg" =~ ^-[^-] ]]; then
            printf -v options ${arg:1}
            options=`echo $options | fold -w1`
            for char in $options; do
                EXPANDED_OPTIONS+=("-${char}")
            done
        else
            EXPANDED_OPTIONS+=("$arg")
        fi
    done
}

function parse_args {
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
             --cores | --jobs | -j)
                CORES="$2"
                shift 2
                ;;
            -h | --help)
                show_usage
                exit 0
                ;;
            -n | --dryrun)
                DRYRUN=" --dryrun "
                shift
                ;;
            --dag)
                DAG=" --dag "
                shift
                ;;
            -s | --snakefile)
                SNAKEFILE="$2"
                shift 2
                ;;
            -c | --configfile)
                CONFIG_FILE="$2"
                shift 2
                ;;
            --skip_config_validation)
                SKIP_CONFIG_VALIDATION="SKIP_CONFIG_VALIDATION"
                shift
                ;;
            *)  # Pass this option/arg through
                PASS_THROUGH_ARGS+=("$1")
                shift
                ;;
        esac
    done
    readonly CORES
    readonly DRYRUN
    readonly DAG
    readonly SNAKEFILE
    readonly CONSOLE_LOG_FILTER
}

set_expanded_options "$@"
parse_args "${EXPANDED_OPTIONS[@]-}"

if [[ ! -f $CONFIG_FILE ]]; then
    echo "ERROR: config file [${CONFIG_FILE}] cannot be read"
    show_usage
    exit 1
else
    export CONFIG_FILEPATH=`readlink -f $CONFIG_FILE`
    export CONFIG_BASENAME=`basename ${CONFIG_FILE}`
fi 

if [[ ! -f $SNAKEFILE ]]; then
    echo "ERROR: snakefile file [${SNAKEFILE}] cannot be read (contact bfxcore support for assistance)"
    exit 1
fi 

if [[ ${SKIP_CONFIG_VALIDATION} == "" ]]; then
    ${WATERMELON_ROOT_DIR}/watermelon_config_validator-runner.py $CONFIG_FILE || exit 1
fi

${WATERMELON_ROOT_DIR}/unlocker-runner.py || exit 1

export EXTRA_ARGUMENTS=""
if [[ ${#PASS_THROUGH_ARGS[@]} -gt 0 ]]; then
  EXTRA_ARGUMENTS="${PASS_THROUGH_ARGS[@]}"
fi

if [ "$DAG" ]; then
    export snakemake_command="snakemake --configfile ${CONFIG_FILE} --snakefile ${SNAKEFILE} ${EXTRA_ARGUMENTS}"
    set -o pipefail
    $snakemake_command --dag | dot -Tpdf > dag.pdf 2>/dev/null && \
    $snakemake_command --rulegraph | dot -Tpdf > dag.rulegraph.pdf 2>/dev/null
    #$snakemake_command --dag | dot > dag.dot && \
    #$snakemake_command --dag | dot -Tsvg > dag.svg && \
    #$snakemake_command --rulegraph | dot > dag.rulegraph.dot && \
    #$snakemake_command --rulegraph | dot -Tsvg > dag.rulegraph.svg
    SNAKEMAKE_EXIT=$?
    if [[ $SNAKEMAKE_EXIT != 0 ]]; then
        echo "ERROR: could not create DAG files"
    else
        echo "Created dag.pdf, dag.rulegraph.pdf"
    fi
    exit $SNAKEMAKE_EXIT
elif [ "$DRYRUN" ]; then
    export LOG_FILE=/dev/null
    export WATERMELON_DETAILED_SUMMARY=/dev/null
    export WATERMELON_EMAIL_ENABLED=false
else
    if [[ -z ${WATERMELON_EMAIL_ENABLED+x} ]]; then
        export WATERMELON_EMAIL_ENABLED=true
    fi
    mkdir -p ${LOG_DIR}
    export LOG_FILEPATH=`readlink -f ${LOG_FILE}`
    SNAKEFILE_BASENAME=`basename ${SNAKEFILE}`
    cp -a ${SNAKEFILE} ${LOG_DIR}/${SNAKEFILE_BASENAME}.${RUN_TIME}
    cp -a ${CONFIG_FILE} ${LOG_DIR}/${CONFIG_BASENAME}.${RUN_TIME}
    export WATERMELON_DETAILED_SUMMARY=${LOG_DIR}/watermelon.detailed_summary
    echo Logging to ${LOG_FILE}
fi

(
echo 0 > .watermelon.exitcode
echo "watermelon (v${WATERMELON_VERSION}) begins"
set +e

snakemake_command="snakemake --printshellcmds --keep-going --configfile ${CONFIG_FILE} --snakefile ${SNAKEFILE} --cores ${CORES} -T ${DRYRUN} ${EXTRA_ARGUMENTS}"
    echo $snakemake_command
unbuffer $snakemake_command
SNAKEMAKE_EXIT=$?

if [[ -z "$DRYRUN" ]]; then
    echo "watermelon: generating result summary"
    snakemake --snakefile ${SNAKEFILE} --configfile ${CONFIG_FILE} -D > ${WATERMELON_DETAILED_SUMMARY}
fi

printf 'elapsed seconds: %d\n' ${SECONDS}
printf 'elapsed time: %dh:%dm:%ds\n' $((${SECONDS}/3600)) $((${SECONDS}%3600/60)) $((${SECONDS}%60))

if [[ $SNAKEMAKE_EXIT != 0 ]]; then
    mail_subject="watermelon failed: ${CONFIG_FILEPATH}"
    mail_message="ERROR: Watermelon failed: ${CONFIG_FILEPATH}.\n"
    if [[ -z "$DRYRUN" ]]; then
        mail_message="${mail_message}watermelon: See logs for details: ${LOG_FILEPATH}"
    fi
    echo ${SNAKEMAKE_EXIT} > .watermelon.exitcode
else
    mail_subject="watermelon complete: ${CONFIG_FILEPATH} (No errors)"
    mail_message=$mail_subject
fi

echo -e ${mail_message}

if [[ "$WATERMELON_EMAIL_ENABLED" = true ]]; then
    ${WATERMELON_SCRIPTS_DIR}/watermelon_mail.sh \
        -s "${mail_subject}" \
        -t "${MAIL_TO}" \
        -c "${MAIL_CC}" \
        -f "${MAIL_FROM}" \
        -m "${mail_message}"
fi

) 2>&1 | tee ${LOG_FILE}

EXIT_CODE=$(cat .watermelon.exitcode)
exit ${EXIT_CODE}
